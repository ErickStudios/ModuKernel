/// __candydef WS::Ebasic

// variables
BuiltIn_i32 let WS::Ebasic::Variable_A
BuiltIn_i32 let WS::Ebasic::Variable_B
BuiltIn_i32 let WS::Ebasic::Variable_C

// rutina de ingreso
BuiltIn_i32 fn _start() {
    // poner argumentos y retorno en el stack
    ->r3 ->r2 r3<- r2<-
    // llamar a la funcion principal
    ErickMain() 
    return
 }
BuiltIn_Void fn WS::Ebasic::LoadA() {
    r1<=WS::Ebasic::Variable_A return
 }
BuiltIn_Void fn WS::Ebasic::LoadB() {
    r1<=WS::Ebasic::Variable_B return
 }
BuiltIn_Void fn WS::Ebasic::LoadC() {
    r1<=WS::Ebasic::Variable_C return
 }
BuiltIn_u8 fn WS::Ebasic::LowToUpr() {
    ->r3 ->r2 r3<- WS::Ebasic::Internals::LowToUpr() 
        return
    BuiltIn_Void fn WS::Ebasic::Internals::LowToUprIsMatch() 
        r1=32 r2-r1 r1=r2 return
    BuiltIn_Void fn WS::Ebasic::Internals::LowToUprIsGreater()
        r1=122 r2?r1 <WS::Ebasic::Internals::LowToUprIsMatch r1=r2 return
    BuiltIn_Void fn WS::Ebasic::Internals::LowToUpr() 
        r1=96 r2?r1 >WS::Ebasic::Internals::LowToUprIsGreater r1=r2 return
 }
BuiltIn_i32 fn ErickMain() {
    // poner argumentos
    ->r3 ->r2 r3<- r2<-
    // el caracter
    r1=43 r1<- WS::Ebasic::LowToUpr()
    // guardar punto de retorno
    ->r1 return
 }